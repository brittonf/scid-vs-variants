Stevenaaus - This patch is not working properly, and is kind-of abandoned.
Previously , it was authored by Ben Hague, and website was http://www.wtfai.me.uk/scid960.html
Up front is a catalog of bugs i had previously found 
----------------------------
Gregor - "The problem with this patch is that it's only a
hack, not a real implementation. A proper implementation requires more work.
The first thing is the preparation of the move board and the move structure
(files position.h, position.cpp, movelist.h),many functions are involved and
have to be changed. Castling should be stored as KxR (e.g. Kf1xg1; currently
it's stored like Ke1-h1), and this change implies also changes on the Tcl
side. After this step the move parser (in position.cpp) needs changes, and the
position of the castling rooks should be stored in class Position. Then the
validation of Chess960 castling can be implemented, this is not trivial and
requires much testing (e.g. hidden attackers have to be considered - this is
not possible in standard chess castling, but in Chess960 castling). After this
the move generator needs work....  I estimate that the realization of Chess960 in
Scid needs some months" 
----------------------------
We have a new 'StandardPosition' in position.[h,cpp] which is not reconciled with [sc_game startBoard]
----------------------------
Nastily - Compiling with -DASSERT, bombs out with - ASSERT FAILED!!: src/position.cpp, line 348
> Position::Gen960Castling (MoveList * mlist)
>    ASSERT (! IsKingInCheck());
----------------------------
I see there is an issue in uci.tcl where neither of these solutions work perfectly.
      if { [catch { sc_move addUCI $m } ] } { return 1 }
      if { [catch { sc_move add $s1 $s2 $p } ] } { return 1 }
(
This position, the best move is pawn queens, but it is not being parsed properly for uci engines (xboard is ok), and is not shown.
rn1q1k2/pp2p2P/3p1n2/2pp4/8/2P5/P1P2PP1/R1BK1B1R w - - 1 17
)
----------------------------
I just played a fics game, and it wouldnt let me castle!  FICS tried to send e8h8 as the uci castling move.
----------------------------
I *think* sc_move_add is the only proc that calls "sc_move addUCI"
(though i don't know where it was used beforehand?)

So it'd be very handy (and a nice speed improvement)
to replace the whole uci::sc_move_add with

  proc sc_move_add {moves} {
    return [sc_move addUCI $moves]
  }

Two things need to be done.
1. add promotion to Position::ReadCoordMove
(Is there any reason we can't do this ? It is only used twice in tkscid.cpp)
2. hack sc_move_addUCI to return success/failure.

Also - your "tk_messageBox -message "Did you castle?""
dialog is not very useable or good. I got a suprise when i saw that,
but haven't looked at the necessity or reason for the dialog.
----------------------------

Index: src/movelist.h
===================================================================
--- src/movelist.h	(revision 2350)
+++ src/movelist.h	(working copy)
@@ -43,15 +43,21 @@
     squareT  capturedSquare; // ONLY different to "to" field if this capture
                             //    is an en passant capture.
     byte     castleFlags;    // pre-move information
+    bool     castling960;
     squareT  epSquare;       // pre-move information
     ushort   oldHalfMoveClock;
     int      score;          // used for alpha/beta ordering.
+        
+    simpleMoveT() 
+    {
+        castling960 = false;
+    }
 };
 
 inline bool isNullMove (simpleMoveT * sm)
 {
-    return (sm->from == sm->to  &&  sm->from != NULL_SQUARE
-              &&  piece_Type(sm->movingPiece) == KING);
+  return (sm->from != NULL_SQUARE && 
+          sm->from == sm->to && (!(piece_Type(sm->movingPiece) == KING && sm->castling960 == true)));
 }
 
 #ifdef WINCE
Index: src/game.cpp
===================================================================
--- src/game.cpp	(revision 2350)
+++ src/game.cpp	(working copy)
@@ -896,6 +896,7 @@
     newsm->to = sm->to;
     newsm->capturedPiece = sm->capturedPiece;
     newsm->promote = sm->promote;
+    newsm->castling960 = sm->castling960;
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -3797,14 +3798,19 @@
         1, 2, 3, 0, 0, 0, 0, 9, 4, 0, 5, 10, 0, 0, 0, 0, 6, 7, 8
     };
 
+    if (diff >= -4 && diff <= 5  && sm->castling960) {
+      if (sm->to == C1 || sm->to == C8) {diff = -2; }
+      if (sm->to == G1 || sm->to == G8) {diff = 2; }
+    }
+    
     // If target square is the from square, it is the null move, which
     // is represented as a king move to its own square and is encoded
     // as the byte value zero.
-    if (sm->to == sm->from) {
+    if (sm->to == sm->from && diff != 2 && diff  != -2) {
         buf->PutByte (makeMoveByte (0, 0));
         return;
     }
-
+    
     // Verify we have a valid King move:
     ASSERT(diff >= -9  &&  diff <= 9  &&  val[diff+9] != 0);
     buf->PutByte (makeMoveByte (0, val [diff + 9]));
@@ -3821,12 +3827,33 @@
     };
 
     if (val == 0) {
-      sm->to = sm->from;  // Null move
-        return OK;
+      if (sm->to < H8) {
+        sm->to = sm->from;  // Null move
+        sm->castling960 = true;
+     }
+      return OK;
     }
-
     if (val < 1  ||  val > 10) { return ERROR_Decode; }
+    
     sm->to = sm->from + sqdiff[val];
+ 
+    if (sqdiff[val] == -2) {
+      sm->castling960 = true;
+      if (sm->from <= G1) {
+        sm->to = C1;
+      } else {
+        sm->to = C8;
+      }
+    }
+    if (sqdiff[val] == 2) {
+      sm->castling960 = true;
+      if (sm->from <= G1) {
+        sm->to = G1;
+      } else {
+        sm->to = G8;
+      }
+    }
+    
     return OK;
 }
 
@@ -4141,7 +4168,8 @@
 
     sm->capturedPiece = EMPTY;
     sm->promote = EMPTY;
-
+    sm->castling960 = false;
+ 
     errorT err = OK;
     pieceT pt = piece_Type (sm->movingPiece);
     switch (pt) {
Index: src/position.cpp
===================================================================
--- src/position.cpp	(revision 2350)
+++ src/position.cpp	(working copy)
@@ -81,6 +81,31 @@
     UnHash (p, sq);
 }
 
+inline void
+Position::AddToBoard960 (pieceT p, squareT sq)
+{
+    Board[sq] = p;
+    NumOnRank[p][square_Rank(sq)]++;
+    NumOnFyle[p][square_Fyle(sq)]++;
+    NumOnLeftDiag[p][square_LeftDiag(sq)]++;
+    NumOnRightDiag[p][square_RightDiag(sq)]++;
+    NumOnSquareColor[p][square_Color(sq)]++;
+    AddHash (p, sq);
+}
+
+inline void
+Position::RemoveFromBoard960 (pieceT p, squareT sq)
+{
+    if (Board[sq] != p) { p = Board[sq]; }
+    Board[sq] = EMPTY;
+    NumOnRank[p][square_Rank(sq)]--;
+    NumOnFyle[p][square_Fyle(sq)]--;
+    NumOnLeftDiag[p][square_LeftDiag(sq)]--;
+    NumOnRightDiag[p][square_RightDiag(sq)]--;
+    NumOnSquareColor[p][square_Color(sq)]--;
+    UnHash (p, sq);
+}
+
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // initHashValues:
 //    Initialises the table of Zobrist hash values.
@@ -220,7 +245,7 @@
 //      Add a legal move to the move list.
 //
 inline void
-Position::AddLegalMove (MoveList * mlist, squareT from, squareT to, pieceT promo)
+Position::AddLegalMove (MoveList * mlist, squareT from, squareT to, pieceT promo, bool castling)
 {
     ASSERT (mlist != NULL);
     simpleMoveT * sm = mlist->Add();
@@ -234,6 +259,7 @@
     sm->promote = promo;
     sm->movingPiece = Board[from];
     sm->capturedPiece = Board[to];
+    sm->castling960 = castling;
 }
 
 
@@ -249,14 +275,13 @@
     squareT dest = fromSq;
     squareT last = square_Last (fromSq, dir);
     int delta = direction_Delta (dir);
-
     while (dest != last) {
         dest += delta;
         pieceT p = Board[dest];
         if (p == EMPTY) {
             if (! capturesOnly) {
                 if (sqset == NULL  ||  sqset->Contains(dest)) {
-                    AddLegalMove (mlist, fromSq, dest, EMPTY);
+                    AddLegalMove (mlist, fromSq, dest, EMPTY, false);
                 }
             }
             continue;
@@ -264,7 +289,7 @@
         // We have reached a piece. Add the capture if it is an enemy.
         if (piece_Color_NotEmpty(p) != color) {
             if (sqset == NULL  ||  sqset->Contains(dest)) {
-                AddLegalMove (mlist, fromSq, dest, EMPTY);
+                AddLegalMove (mlist, fromSq, dest, EMPTY, false);
             }
         }
         break;
@@ -288,64 +313,111 @@
         if (capturesOnly  &&  p == EMPTY) { continue; }
         if (piece_Color(p) != c) {
             if (sqset == NULL  ||  sqset->Contains(dest)) {
-                AddLegalMove (mlist, fromSq, dest, EMPTY);
+                AddLegalMove (mlist, fromSq, dest, EMPTY, false);
             }
         }
     }
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-// Position::GenCastling():
-//    Generate the legal castling moves.
+// Position::Gen960Castling():
+//    Generate the legal castling moves for chess960.
+//
+// Rules are:
+// 1)	Unmoved: The king and the castling rook must not have moved before in
+// the game, including castling.
+//
+// 2)	Unattacked: No square between the king's initial and final squares 
+// (including the initial and final squares) may be under attack by any opposing
+// piece.
+//
+// 3) Unimpeded: All the squares between the king's initial and final squares
+// (including the final square), and all of the squares between the rook's
+// initial and final squares (including the final square), must be vacant except
+// for the king and castling rook. An equivalent way of stating this is that the
+// smallest back rank interval containing the king, the castling rook, and their
+// destination squares contains no pieces other than the king and castling rook.
+//
 //    Assumes the side to move is NOT in check, so the caller
 //    should verify this first.
 //
+
 void
-Position::GenCastling (MoveList * mlist)
+Position::Gen960Castling (MoveList * mlist)
 {
     ASSERT (! IsKingInCheck());
     squareT from = GetKingSquare(ToMove);
-    if (from != (ToMove == WHITE ? E1 : E8))  { return; }
+    if (ToMove == WHITE) {
+        if (((from < B1) || (from > G1)) || Board[from] != WK) {return; }
+    } else {
+        if (((from < B8) || (from > G8)) || Board[from] != BK) {return; }
+    }
+    
     squareT enemyKingSq = GetEnemyKingSquare();
     squareT target, skip, rookSq;
-    pieceT rookPiece;
+    pieceT rookPiece, kingPiece;
 
-    // Try kingside first
+    bool canCastle = true;
 
-    // Kingside Castling:
-    if (!StrictCastling  ||  GetCastling (ToMove, KSIDE)) {
+    // Queenside Castling:
+    if (!StrictCastling  ||  GetCastling (ToMove, QSIDE)) {
         if (ToMove == WHITE) {
-            target = G1; skip = F1; rookSq = H1; rookPiece = WR;
+            target = C1; rookSq = WQRStart; rookPiece = WR; kingPiece = WK;
         } else {
-            target = G8; skip = F8; rookSq = H8; rookPiece = BR;
+            target = C8; rookSq = BQRStart; rookPiece = BR; kingPiece = BK;
         }
-        if (Board[target] == EMPTY  &&  Board[skip] == EMPTY
-                &&  Board[rookSq] == rookPiece
-                &&  CalcNumChecks (target) == 0
-                &&  CalcNumChecks (skip) == 0
-                &&  ! square_Adjacent (target, enemyKingSq)) {
-            AddLegalMove (mlist, from, target, EMPTY);
+        if (from == B1 || from == B8) {
+            if ((Board[target] == EMPTY) || (Board[target] == kingPiece) || (Board[target] == rookPiece)) {
+                if ((Board[target] != EMPTY) || (Board[target + 1] != EMPTY)) { canCastle = false; }
+                if (!(CalcNumChecks (target) == 0) || !(CalcNumChecks (from) == 0)) { canCastle = false; }
+                if (square_Adjacent (target, enemyKingSq) || square_Adjacent (from, enemyKingSq)) { canCastle = false; }
+                if ((Board[rookSq] == rookPiece) && canCastle) {
+                     AddLegalMove (mlist, from, target, EMPTY, true); 
+	        }
+            }
+        } else {
+	  if (!(from == target && Board[target + 1] != EMPTY)) {
+	    if ((Board[target] == EMPTY) || (Board[target] == kingPiece) || (Board[target] == rookPiece)) {
+	        for (skip = from - 1; skip > rookSq; skip--) {	
+                    if (Board[skip] != EMPTY) { canCastle = false; }
+                }
+                for (skip = from; skip >= target; skip--) {
+                    if (!(CalcNumChecks (skip) == 0) || square_Adjacent (skip, enemyKingSq)) { canCastle = false; }
+                }
+                if ((Board[rookSq] == rookPiece) && canCastle) {
+		     AddLegalMove (mlist, from, target, EMPTY, true); 
+	        }
+            }
+	  }
         }
     }
 
-    // Queenside Castling:
-    if (!StrictCastling  ||  GetCastling (ToMove, QSIDE)) {
+    canCastle = true;
+
+    // Kingside Castling:
+    if (!StrictCastling  ||  GetCastling (ToMove, KSIDE)) {
         if (ToMove == WHITE) {
-            target = C1; skip = D1; rookSq = A1; rookPiece = WR;
+            target = G1; rookSq = WKRStart; rookPiece = WR; kingPiece = WK;
         } else {
-            target = C8; skip = D8; rookSq = A8; rookPiece = BR;
+            target = G8; rookSq = BKRStart; rookPiece = BR; kingPiece = BK;
         }
-        if (Board[target] == EMPTY  &&  Board[skip] == EMPTY
-                &&  Board[rookSq] == rookPiece
-                &&  Board[target - 1] == EMPTY // B1 or B8 must be empty too!
-                &&  CalcNumChecks (target) == 0
-                &&  CalcNumChecks (skip) == 0
-                &&  ! square_Adjacent (target, enemyKingSq)) {
-            AddLegalMove (mlist, from, target, EMPTY);
+        if (!((from == target) && (Board[target - 1] != EMPTY))) {
+	  if ((Board[target] == EMPTY) || (Board[target] == kingPiece) || (Board[target] == rookPiece)) {
+            for (skip = from + 1; skip < rookSq; skip++) {
+                if (Board[skip] != EMPTY) { canCastle = false; }
+            }
+            for (skip = from; skip <= target; skip++) {
+                if (!(CalcNumChecks (skip) == 0) || square_Adjacent (skip, enemyKingSq)) { canCastle = false; }
+            }
+            if ((Board[rookSq] == rookPiece) && canCastle) {
+                AddLegalMove (mlist, from, target, EMPTY, true); 
+	    }
+	  }
         }
     }
 }
 
+
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Position::GenKingMoves():
 //      Generate the legal King moves. Castling is generated as well, if
@@ -390,11 +462,11 @@
             Board[kingSq] = king;
             Board[destSq] = captured;
         }
-        if (addThisMove) { AddLegalMove (mlist, kingSq, destSq, EMPTY); }
+        if (addThisMove) { AddLegalMove (mlist, kingSq, destSq, EMPTY, false); }
         destPtr++;
     }
     // Now generate castling moves, if possible:
-    if (genNonCaptures  &&  castling) { GenCastling (mlist); }
+    if (genNonCaptures  &&  castling) { Gen960Castling (mlist); }  
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -408,10 +480,10 @@
     ASSERT (piece_Type (Board[from]) == PAWN);
     ASSERT (square_Rank (dest) == RANK_1  ||  square_Rank (dest) == RANK_8);
 
-    AddLegalMove (mlist, from, dest, QUEEN);
-    AddLegalMove (mlist, from, dest, ROOK);
-    AddLegalMove (mlist, from, dest, BISHOP);
-    AddLegalMove (mlist, from, dest, KNIGHT);
+    AddLegalMove (mlist, from, dest, QUEEN, false);
+    AddLegalMove (mlist, from, dest, ROOK, false);
+    AddLegalMove (mlist, from, dest, BISHOP, false);
+    AddLegalMove (mlist, from, dest, KNIGHT, false);
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -480,13 +552,13 @@
             if (square_Rank(dest) == promoRank) {
                 AddPromotions (mlist, from, dest);
             } else {
-                AddLegalMove (mlist, from, dest, EMPTY);
+                AddLegalMove (mlist, from, dest, EMPTY, false);
             }
         }
         if (square_Rank(from) == secondRank  &&  Board[dest] == EMPTY) {
             dest = square_Move (dest, forward);
             if (Board[dest]==EMPTY  &&  (sqset==NULL || sqset->Contains(dest))) {
-                AddLegalMove (mlist, from, dest, EMPTY);
+                AddLegalMove (mlist, from, dest, EMPTY, false);
             }
         }
     }
@@ -505,7 +577,7 @@
             if (square_Rank(dest) == promoRank) {
                 AddPromotions (mlist, from, dest);
             } else {
-                AddLegalMove (mlist, from, dest, EMPTY);
+                AddLegalMove (mlist, from, dest, EMPTY, false);
             }
         }
     }
@@ -516,7 +588,7 @@
             if (square_Rank(dest) == promoRank) {
                 AddPromotions (mlist, from, dest);
             } else {
-                AddLegalMove (mlist, from, dest, EMPTY);
+                AddLegalMove (mlist, from, dest, EMPTY, false);
             }
         }
     }
@@ -568,8 +640,12 @@
     // Setting up a valid board is left to StdStart() or Clear().
     Board [COLOR_SQUARE] = EMPTY;
     Board [NULL_SQUARE] = END_OF_BOARD;
-	LegalMoves.Clear();
+    LegalMoves.Clear();
     StrictCastling = true;
+    WKRStart = NS;
+    BKRStart = NS;
+    WQRStart = NS;
+    BQRStart = NS;
 
     // Make sure all tables used for move generation, hashing,
     // square tests, etc have been computed:
@@ -604,7 +680,7 @@
     HalfMoveClock = 0;
     Hash = 0;
     PawnHash = 0;
-	LegalMoves.Clear();
+    LegalMoves.Clear();
     return;
 }
 
@@ -654,6 +730,8 @@
         Castling = 0;
         SetCastling (WHITE, QSIDE, true);  SetCastling (WHITE, KSIDE, true);
         SetCastling (BLACK, QSIDE, true);  SetCastling (BLACK, KSIDE, true);
+        SetWQRStart (A1); SetBKRStart (H8); SetBQRStart (A8); SetWKRStart (H1);
+
         EPTarget = NULL_SQUARE;
         ToMove = WHITE;
         PlyCounter = 0;
@@ -661,6 +739,7 @@
         Board [NULL_SQUARE] = END_OF_BOARD;
         Hash = stdStartHash;
         PawnHash = stdStartPawnHash;
+	StandardPosition = true;
     }
     else {
         if (startPositionTemplate == NULL){
@@ -675,6 +754,7 @@
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Position::IsStdStart
 //   Returns true if the position is the standard starting position.
+//   In Chess960, non-standard starts are assumed to be Chess960 games
 bool
 Position::IsStdStart ()
 {
@@ -782,11 +862,10 @@
 Position::GenPieceMoves (MoveList * mlist, squareT fromSq,
                          SquareSet * sqset, bool capturesOnly)
 {
-    colorT c = ToMove;
     pieceT p = Board[fromSq];
     pieceT ptype = piece_Type(p);
+    colorT c = ToMove;
     ASSERT (p != EMPTY  &&  ptype != KING  &&  ptype != PAWN);
-
     if (ptype == KNIGHT) {
         GenKnightMoves (mlist, c, fromSq, sqset, capturesOnly);
         return;
@@ -816,13 +895,12 @@
 {
     bool genNonCaptures = (genType & GEN_NON_CAPS);
     bool capturesOnly = !genNonCaptures;
+    if (LegalMoves.Size() > 0 && pieceType == EMPTY && genType == GEN_ALL_MOVES) {
+        if(mlist != NULL)
+            memcpy (mlist, &LegalMoves, sizeof(MoveList));
+        return;
+    }
 
-	if (LegalMoves.Size() > 0 && pieceType == EMPTY && genType == GEN_ALL_MOVES) {
-		if(mlist != NULL)
-			memcpy (mlist, &LegalMoves, sizeof(MoveList));
-		return;
-	}
-
     uint mask = 0;
     if (pieceType != EMPTY) {
         mask = 1 << pieceType;
@@ -832,9 +910,9 @@
     }
 
     // Use the objects own move list if none was provided:
-	if( mlist == NULL)
-		mlist = &LegalMoves;
-	mlist->Clear();
+    if( mlist == NULL)
+        mlist = &LegalMoves;
+    mlist->Clear();
 
     // Compute which pieces of the side to move are pinned to the king:
     CalcPins();
@@ -862,6 +940,7 @@
         squareT sq = List[ToMove][x];
         pieceT p = Board[sq];
         pieceT ptype = piece_Type(p);
+
         if (! (mask & (1 << ptype))) { continue; }
         directionT pinned = Pinned[x];
 
@@ -900,9 +979,10 @@
         bool castling = !numChecks;
         GenKingMoves (mlist, genType, castling);
     }
+    if (pieceType == EMPTY && genType == GEN_ALL_MOVES && mlist != NULL)
+        memcpy (&LegalMoves, mlist, sizeof(MoveList));
+    
 
-	if (pieceType == EMPTY && genType == GEN_ALL_MOVES && mlist != NULL)
-		memcpy (&LegalMoves, mlist, sizeof(MoveList));
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -980,7 +1060,7 @@
             // The move must be castling, or illegal.
             if (IsKingInCheck()) { return false; }
             MoveList mlist;
-            GenCastling (&mlist);
+            Gen960Castling (&mlist);
             return (mlist.Find(sm) >= 0);
         }
     }
@@ -1112,7 +1192,7 @@
                 if (CalcNumChecks (kingSq) > 0)  { tryMove = 0; }
                 Board[*sqPtr] = p;
                 Board[target] = captured;
-                if (tryMove == 1)  { AddLegalMove (mlist, *sqPtr, target, EMPTY); }
+                if (tryMove == 1)  { AddLegalMove (mlist, *sqPtr, target, EMPTY, false); }
             }
         }
     }
@@ -1233,7 +1313,7 @@
     }
 
     if (legal == 1) {
-        AddLegalMove (mlist, from, to, promote2);
+        AddLegalMove (mlist, from, to, promote2, false);
         return OK;
     }
     return ERROR_InvalidMove;
@@ -1248,78 +1328,26 @@
 errorT
 Position::MatchKingMove (MoveList * mlist, squareT target)
 {
+    bool islegalmove = false;
     mlist->Clear();
-    squareT kingSq = GetKingSquare(ToMove);
-    sint diff = (int)target - (int) kingSq;
-
-    // Valid diffs are: -9, -8, -7, -2, -1, 1, 2, 7, 8, 9. (-2,2: Castling)
-
-    if (diff < -9  ||  diff > 9) { return ERROR_InvalidMove; }
-    if (diff > -7  &&  diff < -2) { return ERROR_InvalidMove; }
-    if (diff > 2  &&  diff < 7) { return ERROR_InvalidMove; }
-    if (diff == 0) { return ERROR_InvalidMove; }
-
-    if (diff == 2) { // KingSide Castling
-        if (kingSq != (ToMove == WHITE ? E1 : E8)) {
-            return ERROR_InvalidMove;
-        }
-        if (StrictCastling  &&  ! GetCastling (ToMove, KSIDE)) {
-            return ERROR_InvalidMove;
-        }
-
-        // XXX We also need to verify that the target square does not
-        //     lie adjacent to the location of the enemy king!
-
-        if (Board[kingSq + 1] != EMPTY  ||  Board[kingSq + 2] != EMPTY
-            ||  CalcNumChecks(kingSq) > 0
-            ||  CalcNumChecks(kingSq + 1) > 0
-            ||  CalcNumChecks(kingSq + 2) > 0) {
-            return ERROR_InvalidMove;
-        }
-        AddLegalMove (mlist, kingSq, target, EMPTY);
-        return OK;
+    genMovesT allmoves = GEN_ALL_MOVES;
+    MoveList tmlist;
+    tmlist.Clear();
+    GenKingMoves(&tmlist, allmoves, true);
+    
+    for (uint i=0; i < tmlist.Size(); i++) {
+       simpleMoveT * sm = tmlist.Get(i);
+       if (sm->to == target) {
+	 mlist->Add(sm);
+	 islegalmove = true;
+       }
     }
-
-    if (diff == -2) { // Queenside Castling
-        if (kingSq != (ToMove == WHITE ? E1 : E8)) {
-            return ERROR_InvalidMove;
-        }
-        if (StrictCastling  &&  ! GetCastling (ToMove, QSIDE)) {
-            return ERROR_InvalidMove;
-        }
-        if (Board[kingSq - 1] != EMPTY  ||  Board[kingSq - 2] != EMPTY
-            ||  Board[kingSq - 3] != EMPTY
-            ||  CalcNumChecks(kingSq) > 0
-            ||  CalcNumChecks(kingSq - 1) > 0
-            ||  CalcNumChecks(kingSq - 2) > 0) {
-            return ERROR_InvalidMove;
-        }
-        AddLegalMove (mlist, kingSq, target, EMPTY);
-        return OK;
+    
+    if (islegalmove) {
+      return OK;
+    } else {
+      return ERROR_InvalidMove;
     }
-    pieceT captured = Board[target];
-    if (piece_Color(captured) == ToMove) {
-        // Capturing a friendly piece!
-        return ERROR_InvalidMove;
-    }
-
-    // Now make the move on the Board and Material lists, and see if it
-    // leaves the King in check:
-    // XXX We should also check for adjacency to enemy King!!
-
-    Board[target] = piece_Make(ToMove, KING);
-    Board[kingSq] = EMPTY;
-    if (captured != EMPTY) { Material[captured]--; }
-    uint legal = 0;
-    if (CalcNumChecks(target) == 0) { legal = 1; }
-    if (captured != EMPTY) { Material[captured]++; }
-    Board[target] = captured;
-    Board[kingSq] = piece_Make(ToMove, KING);
-    if (legal == 1) {
-        AddLegalMove (mlist, kingSq, target, EMPTY);
-        return OK;
-    }
-    return ERROR_InvalidMove;
 }
 
 
@@ -1792,18 +1820,22 @@
 void
 Position::DoSimpleMove (simpleMoveT * sm)
 {
-    ASSERT (sm != NULL);
+   ASSERT (sm != NULL);
     squareT from = sm->from;
     squareT to = sm->to;
     pieceT p = Board[from];
     pieceT ptype = piece_Type(p);
     colorT enemy = color_Flip(ToMove);
     ASSERT (p != EMPTY);
-
     // update move fields that (maybe) have not yet been set:
+    
+    sm->pieceNum = ListPos[from];
 
-    sm->pieceNum = ListPos[from];
-    sm->capturedPiece = Board[to];
+    if (sm->castling960 != true) {
+      sm->capturedPiece = Board[to];
+    } else { 
+      sm->capturedPiece = EMPTY;
+    }
     sm->capturedSquare = to;
     sm->castleFlags = Castling;
     sm->epSquare = EPTarget;
@@ -1811,8 +1843,8 @@
 
     HalfMoveClock++;
     PlyCounter++;
-	LegalMoves.Clear();
-
+    LegalMoves.Clear();
+    
     // Check for a null (empty) move:
     if (isNullMove(sm)) {
         ToMove = enemy;
@@ -1846,8 +1878,8 @@
         Material[sm->capturedPiece]--;
         HalfMoveClock = 0;
         RemoveFromBoard (sm->capturedPiece, sm->capturedSquare);
-    }
-
+     }
+ 
     // handle promotion:
 
     if (sm->promote != EMPTY) {
@@ -1858,32 +1890,54 @@
         Material[p]++;
         AddToBoard (p, from);
     }
-
+   
     // now make the move:
-    List[ToMove][sm->pieceNum] = to;
-    ListPos[to] = sm->pieceNum;
-    RemoveFromBoard (p, from);
-    AddToBoard (p, to);
+   if (sm->castling960 != true) {
+     List[ToMove][sm->pieceNum] = to;
+     ListPos[to] = sm->pieceNum;
+     RemoveFromBoard (p, from);
+     AddToBoard (p, to);
+ }
 
     // handle Castling:
-
-    if (ptype == KING  &&  square_Fyle(from) == E_FYLE  &&
-            (square_Fyle(to) == C_FYLE  ||  square_Fyle(to) == G_FYLE)) {
-        squareT rookfrom, rookto;
-        pieceT rook = piece_Make (ToMove, ROOK);
-        if (square_Fyle(to) == C_FYLE) {
-            rookfrom = to - 2;
-            rookto = to + 1;
+    if (sm->castling960 == true && ptype == KING &&
+         (square_Fyle(to) == C_FYLE  ||  square_Fyle(to) == G_FYLE)) {
+      squareT rookfrom, rookto;
+      pieceT rook = piece_Make (ToMove, ROOK);
+      if (square_Fyle(to) == C_FYLE) {
+        rookto = to + 1;
+        if (ToMove == WHITE) {
+          for (int i = H1; i >= A1; i--) {
+            if (Board[i] == WR) {rookfrom = i;}
+          }
         } else {
-            rookfrom = to + 1;
-            rookto = to - 1;
+          for (int i = H8; i >= A8; i--) {
+           if (Board[i] == BR) {rookfrom = i;}
+          }
         }
-        ListPos[rookto] = ListPos[rookfrom];
-        List[ToMove][ListPos[rookto]] = rookto;
-        RemoveFromBoard (rook, rookfrom);
-        AddToBoard (rook, rookto);
+      } else {
+        rookto = to - 1;
+        if (ToMove == WHITE) {
+          for (int i = A1; i <= H1; i++) {
+            if (Board[i] == WR) { rookfrom = i; }
+          }
+        } else {
+          for (int i = A8; i <= H8; i++) {
+            if (Board[i] == BR) {rookfrom = i;}
+          }
+        }
+      }
+   
+      ListPos[rookto] = ListPos[rookfrom];
+      List[ToMove][ sm->pieceNum] = to;
+      List[ToMove][ListPos[rookto]] = rookto;
+      ListPos[to] = sm->pieceNum;
+ 
+      RemoveFromBoard960 (p, from);
+      RemoveFromBoard960 (rook, rookfrom);
+      AddToBoard960 (p, to);
+      AddToBoard960 (rook, rookto);
     }
-
     // Handle clearing of castling flags:
 
     if (Castling) {
@@ -1893,15 +1947,15 @@
         }
         // See if a rook moved or was captured:
         if (ToMove == WHITE) {
-            if (from == A1)  { SetCastling (WHITE, QSIDE, false); }
-            if (from == H1)  { SetCastling (WHITE, KSIDE, false); }
-            if (to == A8)    { SetCastling (BLACK, QSIDE, false); }
-            if (to == H8)    { SetCastling (BLACK, KSIDE, false); }
+            if (from == WQRStart)  { SetCastling (WHITE, QSIDE, false); }
+            if (from == WKRStart)  { SetCastling (WHITE, KSIDE, false); }
+            if (to == BQRStart)    { SetCastling (BLACK, QSIDE, false); }
+            if (to == BKRStart)    { SetCastling (BLACK, KSIDE, false); }
         } else {
-            if (from == A8)  { SetCastling (BLACK, QSIDE, false); }
-            if (from == H8)  { SetCastling (BLACK, KSIDE, false); }
-            if (to == A1)    { SetCastling (WHITE, QSIDE, false); }
-            if (to == H1)    { SetCastling (WHITE, KSIDE, false); }
+            if (from == BQRStart)  { SetCastling (BLACK, QSIDE, false); }
+            if (from == BKRStart)  { SetCastling (BLACK, KSIDE, false); }
+            if (to == WQRStart)    { SetCastling (WHITE, QSIDE, false); }
+            if (to == WKRStart)    { SetCastling (WHITE, KSIDE, false); }
         }
     }
 
@@ -1923,17 +1977,17 @@
         }
         HalfMoveClock = 0; // 50-move clock resets on pawn moves.
     }
-
     ToMove = enemy;
 
+    
+    
 #ifdef ASSERTIONS
     // Do a SLOW, careful check for corruption:
     if (AssertPos() != OK) {
         abort();
     }
 #endif
-
-    return;
+  return;
 }
 
 
@@ -1944,7 +1998,7 @@
 void
 Position::UndoSimpleMove (simpleMoveT * m)
 {
-    ASSERT (m != NULL);
+   ASSERT (m != NULL);
     squareT from = m->from;
     squareT to = m->to;
     pieceT p = Board[to];
@@ -1954,13 +2008,13 @@
     PlyCounter--;
     ToMove = color_Flip(ToMove);
     m->pieceNum = ListPos[to];
-	LegalMoves.Clear();
-
+    LegalMoves.Clear();
+    
     // Check for a null move:
     if (isNullMove(m)) {
         return;
     }
-
+ 
     // Handle a capture: insert piece back into piecelist.
     // This works for EP captures too, since the square of the captured
     // piece is in the "capturedSquare" field rather than assuming the
@@ -1976,7 +2030,7 @@
         Material[m->capturedPiece]++;
         Count[c]++;
     }
-
+ 
     // handle promotion:
 
     if (m->promote != EMPTY) {
@@ -1986,9 +2040,9 @@
         Material[p]++;
         AddToBoard (p, to);
     }
-
+ 
     // now make the move:
-
+  if (m->castling960 != true) {
     List[ToMove][m->pieceNum] = from;
     ListPos[from] = m->pieceNum;
     RemoveFromBoard (p, to);
@@ -1996,34 +2050,47 @@
     if (m->capturedPiece != EMPTY) {
         AddToBoard (m->capturedPiece, m->capturedSquare);
     }
-
-    // handle Castling:
-
-    if ((piece_Type(p) == KING) && square_Fyle(from) == E_FYLE
-            && (square_Fyle(to) == C_FYLE || square_Fyle(to) == G_FYLE)) {
-        squareT rookfrom, rookto;
-        pieceT rook = (ToMove == WHITE? WR : BR);
-        if (square_Fyle(to) == C_FYLE) {
-            rookfrom = to - 2;   rookto = to + 1;
-        } else {
-            rookfrom = to + 1;   rookto = to - 1;
-        }
-        ListPos[rookfrom] = ListPos[rookto];
-        List[ToMove][ListPos[rookto]] = rookfrom;
-        RemoveFromBoard (rook, rookto);
-        AddToBoard (rook, rookfrom);
+ 
+  }
+  // handle Castling:
+  if ((piece_Type(p) == KING) && m->castling960 == true && (square_Fyle(to) == C_FYLE || square_Fyle(to) == G_FYLE)) {
+    squareT rookfrom, rookto;
+    pieceT rook = (ToMove == WHITE? WR : BR);
+    if (square_Fyle(to) == C_FYLE) {
+      if (ToMove == WHITE) {
+        rookfrom = WQRStart;
+      } else {
+        rookfrom = BQRStart;
+      }
+      rookto = to + 1;
+    } else {
+      if (ToMove == WHITE) {
+        rookfrom = WKRStart;
+      } else {
+        rookfrom = BKRStart;
+      }
+      rookto = to - 1;
     }
+  
+    ListPos[rookfrom] = ListPos[rookto];
+    List[ToMove][ListPos[rookto]] = rookfrom;
+    List[ToMove][ m->pieceNum] = from;
+    ListPos[from] = m->pieceNum;
+   
+    RemoveFromBoard960 (p, to);
+    RemoveFromBoard960 (rook, rookto);
+    AddToBoard960 (p, from);
+    AddToBoard960 (rook, rookfrom);  
+  }
 
 #ifdef ASSERTIONS
     if (AssertPos() != OK) {
         abort();
     }
 #endif
-
     return;
 }
 
-
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Position::RelocatePiece():
 //    Given a from-square and to-square, modifies the position so
@@ -2041,9 +2108,9 @@
 
     // If squares are identical, just return success:
     if (fromSq == toSq) { return OK; }
+    
+    LegalMoves.Clear();
 
-	LegalMoves.Clear();
-
     pieceT piece = Board[fromSq];
     pieceT ptype = piece_Type(piece);
     colorT pcolor = piece_Color(piece);
@@ -2146,11 +2213,11 @@
         if (isNullMove(m)) {
             //*c++ = 'n'; *c++ = 'u'; *c++ = 'l'; *c++ = 'l';
             *c++ = '-'; *c++ = '-';
-        } else
-        if ((square_Fyle(from)==E_FYLE) && (square_Fyle(to)==G_FYLE)) {
+        } else 
+        if (m->castling960 == true && (square_Fyle(to)==G_FYLE)) {
             *c++ = 'O'; *c++ = '-'; *c++ = 'O';
         } else
-        if ((square_Fyle(from)==E_FYLE) && (square_Fyle(to)==C_FYLE)) {
+        if (m->castling960 == true && (square_Fyle(to)==C_FYLE)) {
             *c++ = 'O'; *c++ = '-'; *c++ = 'O'; *c++ = '-'; *c++ = 'O';
         } else {  // regular King move
             *c++ = 'K';
@@ -2207,7 +2274,7 @@
     // Now do the check or mate symbol:
     if (flag != SAN_NO_CHECKTEST) {
         // Now we make the move to test for check:
-		MoveList backup = LegalMoves;
+        MoveList backup = LegalMoves;
         DoSimpleMove (m);
         if (CalcNumChecks (GetKingSquare()) > 0) {
             char ch = '+';
@@ -2219,7 +2286,7 @@
             *c++ = ch;
         }
         UndoSimpleMove (m);
-		LegalMoves = backup;
+        LegalMoves = backup;
     }
     *c = 0;
 }
@@ -2232,13 +2299,12 @@
 Position::MakeUCIString (simpleMoveT * m, char * s)
 {
     ASSERT (m != NULL  &&  s != NULL);
-
     // Make sure m->pieceNum is updated:
     m->pieceNum = ListPos[m->from];
     pieceT  p    = piece_Type (Board[List[ToMove][m->pieceNum]]);
+    pieceT king, rook;
     squareT from = List[ToMove][m->pieceNum];
     squareT to   = m->to;
-
     char * c     = s;
 
     if (from == to && to != NULL_SQUARE) {
@@ -2247,6 +2313,26 @@
       return;
     }
 
+    if (m->castling960) {
+      if (ToMove == WHITE ) {
+        king = WK; 
+        rook = WR;
+        if (to == C1) {
+	  to = WQRStart;
+        } else {
+	  to = WKRStart;
+        }
+      } else {
+        king = BK;
+        rook = BR;
+        if (to == C8) {
+	  to = BQRStart;
+        } else {
+	  to = BKRStart;
+        }
+      }
+    }
+    
     *c++ = square_FyleChar(from);
     *c++ = square_RankChar(from);
     *c++ = square_FyleChar(to);
@@ -2260,6 +2346,7 @@
     *c = 0;
 }
 
+
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Position::ReadCoordMove():
 //      Given a non-promotion move in coordinate notation,
@@ -2274,14 +2361,27 @@
     ASSERT (m != NULL  &&  str != NULL);
     fyleT fromFyle, toFyle;
     rankT fromRank, toRank;
-    squareT from, to;
+    squareT from, to, castle_square;
     pieceT promo = EMPTY;
+    bool castle = false;
+    bool uci = true;
+    pieceT king, rook;
 
     uint slen = strLength(str);
+    if (slen == 6) {
+        promo = piece_FromChar(toupper(str[5]));
+    } else if (slen != 5 && slen != 4) { return ERROR_InvalidMove; }
+
     if (slen == 5) {
-        promo = piece_FromChar(toupper(str[4]));
-    } else if (slen != 4) { return ERROR_InvalidMove; }
-
+      if (str[4] == 't') {
+	castle = true;
+      } else if (str[4] == 'f') {
+	castle = false;
+      } else if (str[4] == 'u') {
+	uci = true;
+      }
+    }
+    
     fromFyle = fyle_FromChar (str[0]);
     fromRank = rank_FromChar (str[1]);
     from = square_Make (fromFyle, fromRank);
@@ -2291,11 +2391,36 @@
     toRank = rank_FromChar (str[3]);
     to = square_Make (toFyle, toRank);
     if (to == NS) { return ERROR_InvalidMove; }
-
     GenerateMoves();
+    
+    if (ToMove == WHITE ) {
+      king = WK; 
+      rook = WR;
+      if (WQRStart == to) {
+	castle_square = C1;
+      } else {
+	castle_square = G1;
+      }
+    } else {
+      king = BK;
+      rook = BR;
+      if (BQRStart == to) {
+	castle_square = C8;
+      } else {
+	castle_square = G8;
+      }
+    }
+    
+    if (Board[to] == rook && Board[from] == king) {
+      castle = true;
+      to = castle_square;
+    }
 
     for (uint i=0; i < LegalMoves.Size(); i++) {
         simpleMoveT * sm = LegalMoves.Get(i);
+        if (!(sm->castling960)) {
+          sm->castling960 = castle;
+        }
         if (sm->promote == promo) {
             if (sm->from == from  &&  sm->to == to) {
                 *m = *sm;
@@ -2323,11 +2448,10 @@
     const char * s = str;
     char mStr [255];
     pieceT p;
-    squareT from = NS;
     squareT to = NS;
     rankT frRank, toRank;
     fyleT frFyle, toFyle;
-
+  
     MoveList mlist;
     mlist.Clear();
 
@@ -2360,7 +2484,7 @@
     if (token == TOKEN_Move_Pawn  ||  token == TOKEN_Move_Promote) {
 
         pieceT promo = EMPTY;
-        if (token == TOKEN_Move_Promote) {
+	   if (token == TOKEN_Move_Promote) {
             // Last char must be Q/R/B/N.
             // Accept the move even if it is of the form "a8Q" not "a8=Q":
             // if (s[slen-2] != '=') { return ERROR_InvalidMove; }
@@ -2377,6 +2501,7 @@
         } else {
             // Check if it is a coordinates-style move, in which case it
             // could be any piece:
+        
             if (slen >= 4  &&
                 islower(s[0])  &&  isdigit(s[1])  &&
                 islower(s[slen-2])  &&  isdigit(s[slen-1])) {
@@ -2386,7 +2511,7 @@
         // First char MUST be a fyle:
         if (*s < 'a'  ||  *s > 'h')  {  return ERROR_InvalidMove; }
         frFyle = fyle_FromChar (s[0]);
-
+        
         // Check for the compact form of capture with no rank,
         // e.g. "ed" or "de=Q":
         if (slen == 2  &&  (s[1] >= 'a'  &&  s[1] <= 'h')) {
@@ -2399,15 +2524,16 @@
                     return OK;
                 }
             }
-            // It is NOT a valid capture with no rank:
+        
+// It is NOT a valid capture with no rank:
             return ERROR_InvalidMove;
         }
-
+        
         toFyle = fyle_FromChar (s[slen-2]);
         toRank = rank_FromChar (s[slen-1]);
         to = square_Make (toFyle, toRank);
         if (to == NS) { return ERROR_InvalidMove; }
-
+        
         if (MatchPawnMove (&mlist, frFyle, to, promo) != OK) {
             return ERROR_InvalidMove;
         } else {
@@ -2415,17 +2541,28 @@
             return OK;
         }
     }
-
+        
     // Here we handle piece moves, including castling
     if (token != TOKEN_Move_Piece) {  // Must be castling move
         ASSERT (token == TOKEN_Move_Castle_King  ||  token == TOKEN_Move_Castle_Queen);
-        from = (ToMove == WHITE ? E1 : E8);
-        if (GetKingSquare(ToMove) != from) { return ERROR_InvalidMove; }
-        to = (token == TOKEN_Move_Castle_King ? (from + 2) : (from - 2));
-        if (MatchKingMove (&mlist, to) != OK) {
+ 	if (token == TOKEN_Move_Castle_Queen) {
+	   if (ToMove == WHITE) { 
+	     to = C1;
+	   } else {
+	     to = C8;
+	   }
+	} else {
+	   if (ToMove == WHITE) { 
+	     to = G1;
+	   } else {
+	     to = G8;
+	   }
+	}
+	if (MatchKingMove (&mlist, to) != OK) {
             return ERROR_InvalidMove;
         } else {
-            *m = *(mlist.Get(0));
+	    *m = *(mlist.Get(0));
+	    m->castling960 = true;
             return OK;
         }
     }
@@ -2841,6 +2978,8 @@
     ASSERT (str != NULL);
     const char * s = str;
     int count = 0;
+    
+    squareT sq;
 
     if (firstCall) {
         firstCall = 0;
@@ -2899,6 +3038,8 @@
 
     if (! IsLegal()) { return ERROR_InvalidFEN; }
 
+    StandardPosition = true;
+    
     // Now the castling flags:
     while (isspace(*s)) { s++; }
     if (*s == '-') {
@@ -2917,21 +3058,96 @@
         }
     } else {
         while (!isspace(*s)  &&  *s != 0) {
-            switch (*s) {
+	    switch (*s) {
             case 'Q':
                 SetCastling (WHITE, QSIDE, true);
-                break;
+		for (int i = H1; i >= A1; i--) {
+		    if (Board[i] == WR) {
+		       SetWQRStart (i);
+		       if (i != A1) { StandardPosition = false; }
+		    }
+		 } 
+		 break;
             case 'q':
                 SetCastling (BLACK, QSIDE, true);
+		for (int i = H8; i >= A8; i--) {
+		    if (Board[i] == BR) {
+		       SetBQRStart (i);
+		       if (i != A8) { StandardPosition = false; }
+		    }
+		 } 
                 break;
             case 'K':
                 SetCastling (WHITE, KSIDE, true);
+		for (int i = A1; i <= H1; i++) {
+		    if (Board[i] == WR) {
+		       SetWKRStart (i);
+		       if (i != H1) { StandardPosition = false; }
+		    }
+		 } 
                 break;
             case 'k':
                 SetCastling (BLACK, KSIDE, true);
+		for (int i = A8; i <= H8; i++) {
+		    if (Board[i] == BR) {
+		       SetBKRStart (i);
+		       if (i != H8) { StandardPosition = false; }
+		    }
+		 } 
                 break;
             default:
-                return ERROR_InvalidFEN;
+		if (*s >= 'A' && *s <= 'H') {
+		  if (*s == 'A') {  sq = A1;}
+		  if (*s == 'B') {  sq = B1;}
+		  if (*s == 'C') {  sq = C1;}
+		  if (*s == 'D') {  sq = D1;}
+		  if (*s == 'E') {  sq = E1;}
+		  if (*s == 'F') {  sq = F1;}
+		  if (*s == 'G') {  sq = G1;}
+		  if (*s == 'H') {  sq = H1;}
+		  for (int i = sq; i <= H1; i++) {
+		     if (Board[i] == WK) {
+		       SetCastling (WHITE, QSIDE, true); 
+		       SetWQRStart (sq);
+		       if (i != A1) { StandardPosition = false; }
+		    }
+		  }
+		  for (int i = sq; i >= A1; i--) {
+		     if (Board[i] == WK) {
+		       SetCastling (WHITE, KSIDE, true);
+		       SetWKRStart (sq);
+		       if (i != H1) { StandardPosition = false; }
+		     }
+		  }
+		} else {
+		  if (*s >= 'a' && *s <= 'h') {
+		  if (*s == 'a') {  sq = A8;}
+		  if (*s == 'b') {  sq = B8;}
+		  if (*s == 'c') {  sq = C8;}
+		  if (*s == 'd') {  sq = D8;}
+		  if (*s == 'e') {  sq = E8;}
+		  if (*s == 'f') {  sq = F8;}
+		  if (*s == 'g') {  sq = G8;}
+		  if (*s == 'h') {  sq = H8;}
+		  for (int i = sq; i <= H8; i++) {
+		     if (Board[i] == BK) {
+		       SetCastling (BLACK, QSIDE, true);
+		       SetBQRStart (sq);
+		       if (i != A8) { StandardPosition = false; }
+		     }
+		  }
+		  for (int i = sq; i >= A8; i--) {
+		     if (Board[i] == BK) {
+		       SetCastling (BLACK, KSIDE, true);
+		       SetBKRStart (sq);		       
+		       if (i != H8) { StandardPosition = false; }
+		    }
+		  }
+		    
+		} else {
+		    return ERROR_InvalidFEN;
+		  }
+		}
             }
             s++;
         }
@@ -2994,39 +3210,115 @@
     ASSERT (str != NULL);
     uint emptyRun, iRank, iFyle;
     pieceT * pBoard = Board;
+    char white[8] = {'A','B','C','D','E','F','G','H'};
+    char black[8] = {'a','b','c','d','e','f','g','h'};
+    bool outside;
     for (iRank = 0; iRank < 8; iRank++) {
         pBoard = &(Board[(7 - iRank) * 8]);
         emptyRun = 0;
         if (iRank > 0  &&  flags > FEN_COMPACT) { *str++ = '/'; }
         for (iFyle = 0; iFyle < 8; iFyle++, pBoard++) {
             if (*pBoard != EMPTY) {
-                if (emptyRun) { *str++ = (byte) emptyRun + '0'; }
+                if (emptyRun) { *str++ = (byte) emptyRun + '0';}
                 emptyRun = 0;
                 *str++ = PIECE_CHAR[*pBoard];
             } else {
                 emptyRun++;
             }
         }
-        if (emptyRun) { *str++ = (byte) emptyRun + '0'; }
+        if (emptyRun) { *str++ = (byte) emptyRun + '0';}
     }
-
+     *str = 0;
     if (flags > FEN_COMPACT) { *str++ = ' '; }
     *str++ = (ToMove == WHITE ? 'w' : 'b');
+    
     *str = 0;
-
+   
     if (flags >= FEN_CASTLING_EP) {
         // Add the castling flags and EP flag as well:
         *str++ = ' ';
         if (Castling == 0)  {
             *str++ = '-';
         } else {
-            if (GetCastling (WHITE, KSIDE))  { *str++ = 'K'; }
-            if (GetCastling (WHITE, QSIDE))  { *str++ = 'Q'; }
-            if (GetCastling (BLACK, KSIDE))  { *str++ = 'k'; }
-            if (GetCastling (BLACK, QSIDE))  { *str++ = 'q'; }
+            if (GetCastling (WHITE, KSIDE))  { 
+	      if ((flags & FEN_XFEN) == 4) {
+	        outside = true;
+	        for (int square = H1; square > WKRStart; square--) {
+		  if (Board[square] == WR) { outside = false; }
+	        }
+	        if (outside) {
+	  	  *str++ = 'K'; 
+	        } else {
+		  *str++ = white[square_Fyle(WKRStart)];
+	        }
+	      } else {
+	        if (StandardPosition) {
+		  *str++ = 'K';
+	        } else {
+		  *str++ = white[square_Fyle(WKRStart)];
+	        }
+	      }
+	    }
+            if (GetCastling (WHITE, QSIDE))  {
+	      if ((flags & FEN_XFEN) == 4) {
+	        outside = true;
+	        for (int square = A1; square < WQRStart; square++) {
+		  if (Board[square] == WR) { outside = false; }
+	        }
+	        if (outside) {
+	  	  *str++ = 'Q'; 
+	        } else {
+		  *str++ = white[square_Fyle(WQRStart)];
+	        }
+	      } else {
+	        if (StandardPosition) {
+		  *str++ = 'Q';
+	        } else {
+		  *str++ = white[square_Fyle(WQRStart)];
+	        }
+	      }
+	    }
+            if (GetCastling (BLACK, KSIDE))  {
+	      if ((flags & FEN_XFEN) == 4) {
+	        outside = true;
+	        for (int square = H8; square > BKRStart; square--) {
+	  	  if (Board[square] == BR) { outside = false; }
+	        }
+	        if (outside) {
+		  *str++ = 'k'; 
+	        } else {
+		  *str++ = black[square_Fyle(BKRStart)];
+	        } 
+	      } else {
+	        if (StandardPosition) {
+		  *str++ = 'k';
+	        } else {
+		  *str++ = black[square_Fyle(BKRStart)];
+	        }
+	      }
+	    }
+            if (GetCastling (BLACK, QSIDE))  {
+	      if ((flags & FEN_XFEN) == 4) {
+	        outside = true;
+	        for (int square = A8; square < BQRStart; square++) {
+	  	  if (Board[square] == BR) { outside = false; }
+	        }
+	        if (outside) {
+		  *str++ = 'q'; 
+	        } else {
+		  *str++ = black[square_Fyle(BQRStart)];
+	        }
+	      } else {
+	        if (StandardPosition) {
+		  *str++ = 'q';
+	        } else {
+		  *str++ = black[square_Fyle(BQRStart)];
+	        }
+	      }
+	    }
         }
         *str++ = ' ';
-
+   
         // Now the EP target square:
         if (EPTarget == NULL_SQUARE) {
             *str++ = '-';
@@ -3191,7 +3483,7 @@
 void
 Position::CopyFrom (Position * src)
 {
-  memcpy (this, src, sizeof(Position));
+    memcpy (this, src, sizeof(Position));
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -3228,7 +3520,7 @@
     pieceT pieces [32];         // List of pieces excluding kings
     uint nPieces[2] = {0, 0};   // Number of pieces per side excluding kings.
     uint total = 0;             // Total number of pieces excluding kings.
-	LegalMoves.Clear();
+    LegalMoves.Clear();
 
     colorT side = WHITE;
 
Index: src/position.h
===================================================================
--- src/position.h	(revision 2350)
+++ src/position.h	(working copy)
@@ -45,7 +45,8 @@
     FEN_COMPACT = 0,
     FEN_BOARD = 1,
     FEN_CASTLING_EP = 2,
-    FEN_ALL_FIELDS = 3;
+    FEN_ALL_FIELDS = 3,
+    FEN_XFEN = 4;
 
 
 // Flags that Position::GenerateMoves() recognises:
@@ -103,12 +104,16 @@
     byte            Castling;       // castling flags
     bool            StrictCastling; // If false, allow castling after moving
                                         // the King or Rook.
+    squareT         WKRStart, BKRStart, WQRStart, BQRStart; // The initial squares
+                                                            // of the rooks  
 
     uint            Hash;           // Hash value.
     uint            PawnHash;       // Pawn structure hash value.
 
     MoveList        LegalMoves;     // list of legal moves
 
+    bool            StandardPosition; // Normal game or Chess960
+    
     //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     //  Position:  Private Functions
 
@@ -117,6 +122,8 @@
 
     inline void AddToBoard (pieceT p, squareT sq);
     inline void RemoveFromBoard (pieceT p, squareT sq);
+    inline void AddToBoard960 (pieceT p, squareT sq);
+    inline void RemoveFromBoard960 (pieceT p, squareT sq);
 
     void  CalcPinsDir (directionT dir, pieceT attacker);
 
@@ -126,8 +133,8 @@
     void  GenKnightMoves (MoveList * mlist, colorT c, squareT sq,
                           SquareSet * sqset, bool capturesOnly);
 
-    void  AddLegalMove (MoveList * mlist, squareT from, squareT to, pieceT promo);
-    void  GenCastling (MoveList * mlist);
+    void  AddLegalMove (MoveList * mlist, squareT from, squareT to, pieceT promo, bool castling);
+    void  Gen960Castling (MoveList * mlist);
     void  GenKingMoves (MoveList * mlist, genMovesT genType, bool castling);
     void  AddPromotions (MoveList * mlist, squareT from, squareT dest);
     bool  IsValidEnPassant (squareT from, squareT to);
@@ -178,6 +185,16 @@
     void        SetPlyCounter (ushort x) { PlyCounter = x; }
     ushort      GetPlyCounter ()         { return PlyCounter; }
     ushort      GetFullMoveCount ()      { return PlyCounter / 2 + 1; }
+    MoveList    GetLegalMoves ()         { return LegalMoves; }
+    void        SetWKRStart (squareT s)  { WKRStart = s; }
+    void        SetBKRStart (squareT s)  { BKRStart = s; }
+    void        SetWQRStart (squareT s)  { WQRStart = s; }
+    void        SetBQRStart (squareT s)  { BQRStart = s; }
+    squareT     GetWKRStart ()  { return WKRStart; }
+    squareT     GetBKRStart ()  { return BKRStart; }
+    squareT     GetWQRStart ()  { return WQRStart; }
+    squareT     GetBQRStart ()  { return BQRStart; }
+    bool        GetStandardPosition () { return StandardPosition; }
 
     // Methods to get the Board or piece lists -- used in game.cpp to
     // decode moves:
Index: src/tkscid.h
===================================================================
--- src/tkscid.h	(revision 2350)
+++ src/tkscid.h	(working copy)
@@ -515,7 +515,9 @@
 int sc_move_addSan    (TCL_ARGS);
 int sc_move_addUCI    (TCL_ARGS);
 int sc_move_back      (TCL_ARGS);
+int sc_move_duplicate (TCL_ARGS);
 int sc_move_forward   (TCL_ARGS);
+int sc_move_inplace   (TCL_ARGS);
 int sc_move_pgn       (TCL_ARGS);
 
 int sc_name           (TCL_ARGS);
Index: src/movelist.cpp
===================================================================
--- src/movelist.cpp	(revision 2350)
+++ src/movelist.cpp	(working copy)
@@ -165,7 +165,7 @@
     writeOneByte (fp, sm->capturedPiece);
 
     writeOneByte (fp, sm->promote);
-    writeOneByte (fp, 0);     // Obsolete unused value
+    writeOneByte (fp, sm->castling960);
 
     writeOneByte (fp, sm->capturedSquare);
     writeOneByte (fp, sm->castleFlags);
@@ -192,7 +192,7 @@
     sm->capturedPiece = readOneByte (fp);
 
     sm->promote = readOneByte (fp);
-    readOneByte (fp);   // Obsolete unused value
+    sm->castling960 = readOneByte (fp);
 
     sm->capturedSquare = readOneByte (fp);
     sm->castleFlags = readOneByte (fp);
Index: src/tkscid.cpp
===================================================================
--- src/tkscid.cpp	(revision 2350)
+++ src/tkscid.cpp	(working copy)
@@ -10121,11 +10121,11 @@
 {
     static const char * options [] = {
         "add", "addSan", "addUCI", "back", "end", "forward",
-        "pgn", "ply", "start", NULL
+        "pgn", "ply", "start", "duplicate", "inplace", NULL
     };
     enum {
         MOVE_ADD, MOVE_ADDSAN, MOVE_ADDUCI, MOVE_BACK, MOVE_END, MOVE_FORWARD,
-        MOVE_PGN, MOVE_PLY, MOVE_START
+        MOVE_PGN, MOVE_PLY, MOVE_START, MOVE_DUPLICATE, MOVE_INPLACE
     };
     int index = -1;
 
@@ -10144,6 +10144,9 @@
     case MOVE_BACK:
         return sc_move_back (cd, ti, argc, argv);
 
+    case MOVE_DUPLICATE:
+        return sc_move_duplicate (cd, ti, argc, argv);
+
     case MOVE_END:
         db->game->MoveToPly(0);
         {
@@ -10157,6 +10160,9 @@
     case MOVE_FORWARD:
         return sc_move_forward (cd, ti, argc, argv);
 
+    case MOVE_INPLACE:
+        return sc_move_inplace (cd, ti, argc, argv);
+    
     case MOVE_PGN:
         return sc_move_pgn (cd, ti, argc, argv);
 
@@ -10182,32 +10188,40 @@
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-// sc_move_add: takes a move specified by three parameters
-//      (square square promo) and adds it to the game.
+// sc_move_add: takes a move specified by four parameters
+//      (square square castling promo) and adds it to the game.
 int
 sc_move_add (ClientData cd, Tcl_Interp * ti, int argc, const char ** argv)
 {
 
-    if (argc != 5) {
-        return errorResult (ti, "Usage: sc_move add <sq> <sq> <promo>");
+    if (argc != 6) {
+        return errorResult (ti, "Usage: sc_move add <sq> <sq> <promo> <castle>");
     }
 
     uint sq1 = strGetUnsigned (argv[2]);
     uint sq2 = strGetUnsigned (argv[3]);
     uint promo = strGetUnsigned (argv[4]);
     if (promo == 0) { promo = EMPTY; }
+    uint castle = strGetUnsigned (argv[5]);
+    if (castle == 0) { castle = EMPTY; }
 
     char s[8];
     s[0] = square_FyleChar (sq1);
     s[1] = square_RankChar (sq1);
     s[2] = square_FyleChar (sq2);
     s[3] = square_RankChar (sq2);
+    if (castle == EMPTY ) {
+      s[4] = 'f';
+    } else {
+      s[4] = 't';
+    } 
     if (promo == EMPTY) {
-        s[4] = 0;
+        s[5] = 0;
     } else {
-        s[4] = piece_Char(promo);
-        s[5] = 0;
+        s[5] = piece_Char(promo);
+        s[6] = 0;
     }
+
     simpleMoveT sm;
     Position * pos = db->game->GetCurrentPos();
     errorT err = pos->ReadCoordMove (&sm, s, true);
@@ -10279,13 +10293,22 @@
         ptr += 4;        
       } else {
         s[4] = ptr[4];
-        s[5] = 0;
-        ptr += 6;
+        if (ptr[5] == ' ') {
+	  s[5] = 0;
+	  ptr += 6;
+        } else if (ptr[5] == 0) {
+	  s[5] = 0;
+	  ptr += 5;
+        } else { 
+          // oops 
+          break;
+        }
       }
       simpleMoveT sm;
       Position * pos = db->game->GetCurrentPos();
       errorT err = pos->ReadCoordMove (&sm, s, true);
       if (err == OK) {
+// fixme printf ("%s ok\n",s);
         err = db->game->AddMove (&sm, NULL);
         if (err == OK) {
             db->gameAltered = true;
@@ -10297,6 +10320,7 @@
             break;
         }
       } else {
+printf ("%s fail\n",s);
         //Tcl_AppendResult (ti, "Error reading move(s): ", ptr, NULL);
         break;
       }
@@ -10328,6 +10352,39 @@
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+// sc_move_duplicate
+//
+// Takes two squares and returns true if there are two moves with those squares, false otherwise
+int
+sc_move_duplicate(ClientData cd, Tcl_Interp * ti, int argc, const char ** argv)
+{
+    if (argc != 4) {
+        return errorResult (ti, "Usage: sc_move duplicate <from sq> <to sq>");
+    }
+
+    uint tosq = strGetUnsigned (argv[2]);
+    uint fromsq = strGetUnsigned (argv[3]);
+    uint timesAppeared = 0;
+    
+    Position * pos = db->game->GetCurrentPos();
+    pos->GenerateMoves();
+    MoveList mList = pos->GetLegalMoves();
+    for (uint i=0; i < mList.Size(); i++) {
+      simpleMoveT * sm = mList.Get(i);
+      if (sm->to == tosq && sm->from == fromsq) {timesAppeared++;}
+    }	
+    if (timesAppeared == 0) {
+      for (uint i=0; i < mList.Size(); i++) {
+         simpleMoveT * sm = mList.Get(i);
+         if (sm->to == fromsq && sm->from == tosq) {timesAppeared++;}
+     }
+    }
+    if (timesAppeared > 1) {setBoolResult(ti, true);} else {setBoolResult(ti, false);}
+   
+    return TCL_OK;
+}
+
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // sc_move_forward:
 //    Moves forward a specified number of moves (default = 1 move).
 int
@@ -10351,6 +10408,33 @@
 }
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+// sc_move_inplace
+//
+// Takes one square and returns true if there are two moves with those squares, false otherwise
+int
+sc_move_inplace(ClientData cd, Tcl_Interp * ti, int argc, const char ** argv)
+{
+    if (argc != 3) {
+        return errorResult (ti, "Usage: sc_move inplace <sq>");
+    }
+
+    uint sq = strGetUnsigned (argv[2]);
+    
+    Position * pos = db->game->GetCurrentPos();
+    pos->GenerateMoves();
+     
+    MoveList mList = pos->GetLegalMoves();
+    for (uint i=0; i < mList.Size(); i++) {
+      simpleMoveT * sm = mList.Get(i);
+      if (sm->to == sq && sm->from == sq) {
+        setBoolResult(ti, true);
+        return TCL_OK;
+      }
+    }	
+    setBoolResult(ti, false);
+    return TCL_OK;
+}
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // sc_move_pgn:
 //    Set the current board to the position closest to
 //    the specified place in the PGN output (given as a byte count
Index: tcl/lang/swedish.tcl
===================================================================
--- tcl/lang/swedish.tcl	(revision 2350)
+++ tcl/lang/swedish.tcl	(working copy)
@@ -1711,6 +1711,8 @@
 translate W IERotate  {Rotera}
 translate W IEUnableToStart {Kan inte starta Inmatningsmotor:}
 translate W DoneWithPosition {Klar med position}
+# ====== TODO To be translated ======
+translate W DidYouCastle {Did you castle?}
 translate W Board {Brde}
 translate W showGameInfo {Visa partiinformation}
 translate W autoResizeBoard {ndra storleken p brdet automatiskt}
Index: tcl/lang/serbian.tcl
===================================================================
--- tcl/lang/serbian.tcl	(revision 2350)
+++ tcl/lang/serbian.tcl	(working copy)
@@ -2148,6 +2148,8 @@
 # ====== TODO To be translated ======
 translate Y DoneWithPosition {Done with position}
 # ====== TODO To be translated ======
+translate Y DidYouCastle {Did you castle?}
+# ====== TODO To be translated ======
 translate Y Board {Board}
 # ====== TODO To be translated ======
 translate Y showGameInfo {Show game info}
Index: tcl/lang/english.tcl
===================================================================
--- tcl/lang/english.tcl	(revision 2350)
+++ tcl/lang/english.tcl	(working copy)
@@ -1700,5 +1700,8 @@
 translate E EmptyUriList {Drop content is empty.}
 translate E SelectionOwnerDidntRespond {Timeout during drop action: selection owner didn't respond.}
 
+# Ask about ambiguous castling in chess 960
+translate E DidYouCastle {Did you castle?}
+
 }
 # end of english.tcl
Index: tcl/lang/norsk.tcl
===================================================================
--- tcl/lang/norsk.tcl	(revision 2350)
+++ tcl/lang/norsk.tcl	(working copy)
@@ -2143,6 +2143,8 @@
 # ====== TODO To be translated ======
 translate O DoneWithPosition {Done with position}
 # ====== TODO To be translated ======
+translate O DidYouCastle {Did you castle?}
+# ====== TODO To be translated ======
 translate O Board {Board}
 # ====== TODO To be translated ======
 translate O showGameInfo {Show game info}
Index: tcl/tools/uci.tcl
===================================================================
--- tcl/tools/uci.tcl	(revision 2353)
+++ tcl/tools/uci.tcl	(working copy)
@@ -35,6 +35,7 @@
     set uciInfo(scoremate$n) ""
     set uciInfo(currmove$n) ""
     set uciInfo(currmovenumber$n) 0
+    set uciInfo(chess960$n) 0
     # hmmm
     # set uciInfo(score$n) ""
   }
@@ -63,6 +64,9 @@
 
   # todo: sort out the analyze var with computer tournament feature &&&
 
+set ::ccg 0
+set ::ccc 0
+
   proc processAnalysisInput { {n 1} {gui 1} } {
     global analysis annotate comp ::uci::uciInfo ::uci::optionToken 
 
@@ -303,8 +307,17 @@
 
       # convert to something more readable
       if ($toBeFormatted) {
+incr ::ccc
+incr ::ccg [lindex [time {
         set uciInfo(pv$n) [formatPv $n $uciInfo(pv$n)]
         set toBeFormatted 0
+}] 0]
+if {$::ccc == 20} {
+set ::ccc 0
+puts "avg [expr $::ccg / 20]"
+set ::ccg 0
+}
+
       }
 
       set idx [ expr $uciInfo(multipv$n) -1 ]
@@ -814,6 +827,7 @@
 
   proc sendUCIoptions {n} {
     global analysis
+
     set engineData [ lindex $::engines(list) $n ]
     set options [ lindex $engineData 8 ]
     foreach opt $options {
@@ -974,17 +988,19 @@
   # returns 1 if an error occured when entering a move
   ################################################################################
   proc sc_move_add { moves } {
+    sc_move addUCI $moves
+    return 0
 
+# todo fixme
+
     foreach m $moves {
       # get rid of leading piece
       set c [string index $m 0]
       if {$c in {K Q R B N}} {
         set m [string range $m 1 end]
       }
-      set s1 [string range $m 0 1]
-      set s1 [::board::sq $s1]
-      set s2 [string range $m 2 3]
-      set s2 [::board::sq $s2]
+      set s1 [::board::sq [string range $m 0 1]]
+      set s2 [::board::sq [string range $m 2 3]]
       if {[string length $m] > 4} {
         set promo [string range $m 4 end]
         # inverse transformation : const char PIECE_CHAR [] = "xKQRBNP.xkqrbnpxMm";
@@ -1000,9 +1016,12 @@
           n { set p 5}
           default {puts "Promo error $promo for moves $moves"}
         }
-        if { [catch { sc_move add $s1 $s2 $p } ] } { return 1 }
+
+	if { [catch { sc_move addUCI $m } ] } { return 1 }
+        # if { [catch { sc_move add $s1 $s2 $p } ] } { return 1 }
       } else  {
-        if { [catch { sc_move add $s1 $s2 0 } ] } { return 1 }
+	if { [catch { sc_move addUCI $m } ] } { return 1 }
+        # if { [catch { sc_move add $s1 $s2 0 } ] } { return 1 }
       }
     }
     return 0
Index: tcl/tools/analysis.tcl
===================================================================
--- tcl/tools/analysis.tcl	(revision 2350)
+++ tcl/tools/analysis.tcl	(working copy)
@@ -3154,6 +3154,9 @@
     if {$analysis(has_setboard$n)} {
       sendToEngine $n "setboard [sc_pos fen]"
     }
+    # fixme Xboard engines must be init here with chess960
+    # - test whether they support "variant fischerrandom"
+
     if { $analysis(has_analyze$n) } {
       # why is this commented out. It crashes engine when re-instated S.A
       #updateAnalysis $n
@@ -3625,8 +3628,12 @@
     # proc is called for any change in board position (including new games, and simple moves)
     set nonStdStart [sc_game startBoard]
     if {$nonStdStart} {
+      # todo - fixme. This is not accurate. In position.[h,cpp], chess960 is implementing it's own bool, StandardPosition,
+      # which is separate from [sc_game startBoard] which we are using here.
+      sendToEngine $n "setoption name UCI_Chess960 value true"
       set analysis(startpos$n) "fen [sc_game startPos]"
     } else {
+      sendToEngine $n "setoption name UCI_Chess960 value false"
       set analysis(startpos$n) startpos
     }
   }
@@ -3721,12 +3728,16 @@
 	if {$analysis(isCrafty$n)} {
           sendToEngine $n "mn [sc_pos moveNumber]"
         }
+
+        if {$nonStdStart} {
+	  sendToEngine $n "variant fischerrandom"
+        }
+
 	sendToEngine $n analyze
 	return
       }
       
       ### Ok- no "setboard"
-
       if {$nonStdStart} {
         set analysis(moves$n) "  Sorry, this game has a non-standard start position."
         updateAnalysisText $n
@@ -3766,6 +3777,10 @@
 	}
 	
       }
+
+      if { [sc_game info standard] == 0 } {
+	sendToEngine $n "variant fischerrandom"
+      }
       
       sendToEngine $n analyze
       
@@ -3782,6 +3797,11 @@
       if {(!$windowsOS)  &&  $analysis(send_sigint$n)} {
 	catch {exec -- kill -s INT [pid $analysis(pipe$n)]}
       }
+
+      if { [sc_game info standard] == 0 } {
+	sendToEngine $n "variant fischerrandom"
+      }
+
       sendToEngine $n new
       sendToEngine $n force
       if { $nonStdStart && ! $analysis(has_setboard$n) } {
@@ -3789,6 +3809,7 @@
 	updateAnalysisText $n
 	return
       }
+
       if {$analysis(has_setboard$n)} {
 	sendToEngine $n "setboard [sc_pos fen]"
       } else  {
Index: tcl/main.tcl
===================================================================
--- tcl/main.tcl	(revision 2350)
+++ tcl/main.tcl	(working copy)
@@ -1293,7 +1293,21 @@
     sc_move addSan null
   } else {
     # if {[winfo exists .commentWin]} { .commentWin.cf.text delete 0.0 end }
-    sc_move add $sq1 $sq2 $promo
+
+    set castle 0
+    if {[sc_move duplicate $sq1 $sq2] == 1} {
+       set answer [tk_messageBox -message "Did you castle?" -type yesno -icon question]
+       switch -- $answer {
+           yes {set castle 1}
+           no {set castle 0}
+       }
+    }
+    if {[sc_move inplace $sq1] == 1} {
+       set castle 1
+    }
+    sc_move add $sq1 $sq2 $promo $castle
+
+
     set san [sc_game info previous]
     if {$action == "mainline"} {
       sc_var exit
@@ -1462,7 +1476,7 @@
 
   if { [winfo exists .calvarWin] } { return }
 
-  global selectedSq bestSq
+  global selectedSq bestSq currentSq
 
   ::board::setDragSquare $w -1
   set square [::board::getSquare $w $x $y]
@@ -1472,6 +1486,20 @@
   }
 
   if {$square == $selectedSq} {
+    set castle 0
+    if {[sc_move inplace $square] == 1} {
+	set answer [tk_messageBox -message $DidYouCastle -type yesno -icon question]
+	switch -- $answer {
+	    yes {
+		set selectedSq -1
+		::board::colorSquare $w $square
+
+		addMove $square $square -animate
+		enterSquare $square
+	    }
+	    no {}
+	}
+   } else {
     if {$::suggestMoves} {
       # User pressed and released on same square, so make the
       # suggested move if there is one:
@@ -1484,6 +1512,7 @@
       # Current square is the square user pressed the button on,
       # so we do nothing.
     }
+   }
   } else {
     if {$selectedSq == -1} {
       return
Index: tcl/edit.tcl
===================================================================
--- tcl/edit.tcl	(revision 2350)
+++ tcl/edit.tcl	(working copy)
@@ -411,7 +411,7 @@
   makeSetupFen
 }
 proc check_castling {a b c} {
-  ::utils::validate::Regexp {^(-|[KQkq]*)$} $a $b $c
+  ::utils::validate::Regexp {^(-|[KQkqa-hA-H]*)$} $a $b $c
   makeSetupFen
 }
 trace variable moveNum w check_moveNum
Index: tcl/board.tcl
===================================================================
--- tcl/board.tcl	(revision 2350)
+++ tcl/board.tcl	(working copy)
@@ -2593,6 +2593,8 @@
   if {$diffcount == 4} {
     # Check for making/unmaking a castling move
 
+    set normalcastle 0
+
     set oldlower [string tolower $oldboard]
     set newlower [string tolower $newboard]
 
@@ -2608,6 +2610,7 @@
           eval $w.bd coords p$rto [::board::midSquare $w $rfrom]
           set from $kfrom
           set to $kto
+          set normalcastle 1
         } elseif {[string index $newlower $kfrom] == {k}  &&
 	    [string index $newlower $rfrom] == {r}  &&
 	    [string index $oldlower $kto] == {k}  &&
@@ -2615,13 +2618,50 @@
           # An undo-castling animation. No need to move the rook.
           set from $kto
           set to $kfrom
+          set normalcastle 1
         }
       }
     }
+    if {$normalcastle == 0} {
+      set oldcount 0
+      set newcount 0
+      for {set i 0} {$i < $diffcount} {incr i} {
+        if {$old($i) != "."} {
+          set oldone($oldcount) $old($i)
+          set oldsquare($oldcount) $sq($i)
+          incr oldcount
+        }
+        if {$new($i) != "."} {
+          set newone($newcount) $new($i)
+          set newsquare($newcount) $sq($i)
+          incr newcount
+        }
+      }
+      if {([string tolower $oldone(0)] == "r" && [string tolower $oldone(1)] == "k" && 
+           [string tolower $newone(0)] == "k" && [string tolower $newone(1)] == "r") ||
+          ([string tolower $oldone(0)] == "k" && [string tolower $oldone(1)] == "r" && 
+           [string tolower $newone(0)] == "r" && [string tolower $newone(1)] == "k")} {
+        if {($newone(0) == "k" || $newone(1) == "k") && $newsquare(0) >= [sq a8] && $newsquare(1) >= [sq a8]} {
+        } else {
+          if {($newone(0) == "K" || $newone(1) == "K") && $newsquare(0) <= [sq h1] && $newsquare(1) <= [sq h1]} {
+         } else {
+              return
+            }
+          }
+        if {[string tolower $oldone(0)] == "k"} {
+          set from $newsquare(0)
+          set to $newsquare(1) 
+        } else {
+          set from $newsquare(1)
+          set to $newsquare(0) 
+        }
+      }
+    }
   }
 
   if {$diffcount == 3} {
     # Three squares are different, so check for an En Passant capture:
+    set enpassant 0
     foreach i {0 1 2} {
       foreach j {0 1 2} {
         foreach k {0 1 2} {
@@ -2633,6 +2673,7 @@
             ($old($i) == "P" && $old($k) == "p"))} {
             set from $sq($i)
             set to $sq($j)
+            set enpassant 1
           }
           # Check for undoing an en-passant capture from j to i with
           # the enemy pawn on k:
@@ -2643,10 +2684,46 @@
             set to $sq($j)
             set captured $sq($k)
             set capturedPiece $new($k)
+            set enpassant 1
           }
         }
       }
     }
+    if {$enpassant == 0} {
+      set oldcount 0
+      set newcount 0
+      for {set i 0} {$i < $diffcount} {incr i} {
+        if {$old($i) != "."} {
+          set oldone($oldcount) $old($i)
+          set oldsquare($oldcount) $sq($i)
+          incr oldcount
+        }
+        if {$new($i) != "."} {
+          set newone($newcount) $new($i)
+          set newsquare($newcount) $sq($i)
+          incr newcount
+        }
+      }
+      if {([string tolower $oldone(0)] == "r" && [string tolower $oldone(1)] == "k" && 
+           [string tolower $newone(0)] == "k" && [string tolower $newone(1)] == "r") ||
+          ([string tolower $oldone(0)] == "k" && [string tolower $oldone(1)] == "r" && 
+           [string tolower $newone(0)] == "r" && [string tolower $newone(1)] == "k")} {
+        if {($newone(0) == "k" || $newone(1) == "k") && $newsquare(0) >= [sq a8] && $newsquare(1) >= [sq a8]} {
+        } else {
+          if {($newone(0) == "K" || $newone(1) == "K") && $newsquare(0) <= [sq h1] && $newsquare(1) <= [sq h1]} {
+         } else {
+              return
+            }
+          }
+        if {[string tolower $oldone(0)] == "k"} {
+          set from $newsquare(0)
+          set to $newsquare(1) 
+        } else {
+          set from $newsquare(1)
+          set to $newsquare(0) 
+        }
+      }
+    }
   }
 
   if {$diffcount == 2} {
@@ -2654,6 +2731,25 @@
     # same (non-empty) piece as the other new square, and at least one
     # of the old or new squares should be empty.
 
+   if {([string tolower $old(0)] == "r" && [string tolower $old(1)] == "k" && 
+        [string tolower $new(0)] == "k" && [string tolower $new(1)] == "r") ||
+        ([string tolower $old(0)] == "k" && [string tolower $old(1)] == "r" && 
+        [string tolower $new(0)] == "r" && [string tolower $new(1)] == "k")} {
+        if {($new(0) == "k" || $new(1) == "k") && $sq(0) >= [sq a8] && $sq(1) >= [sq a8]} {
+        } else {
+            if {($new(0) == "K" || $new(1) == "K") && $sq(0) <= [sq h1] && $sq(1) <= [sq h1]} {
+            } else {
+                return
+            }
+        }
+        if {[string tolower $old(0)] == "k"} {
+            set from $sq(0)
+            set to $sq(1) 
+        } else {
+            set from $sq(1)
+            set to $sq(0) 
+        }
+    } else { 
     if {$old(0) != "." && $old(1) != "." && $new(0) != "." && $new(1) != "."} {
       return
     }
@@ -2690,6 +2786,7 @@
       }
     }
   }
+  }
 
   # Check that we found a valid-looking move to animate:
   if {$from < 0  ||  $to < 0} { return }
